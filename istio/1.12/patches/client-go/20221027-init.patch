diff --git a/go.mod b/go.mod
index cd921ff..6f4ad30 100644
--- a/go.mod
+++ b/go.mod
@@ -7,3 +7,5 @@ require (
 	k8s.io/apimachinery v0.21.0
 	k8s.io/client-go v0.21.0
 )
+
+replace istio.io/api => ../api
diff --git a/pkg/apis/networking/v1alpha3/register.gen.go b/pkg/apis/networking/v1alpha3/register.gen.go
index 3b6f484..e4e1c16 100644
--- a/pkg/apis/networking/v1alpha3/register.gen.go
+++ b/pkg/apis/networking/v1alpha3/register.gen.go
@@ -49,6 +49,8 @@ func addKnownTypes(scheme *runtime.Scheme) error {
 		&GatewayList{},
 		&ServiceEntry{},
 		&ServiceEntryList{},
+		&ServiceSubscriptionList{},
+		&ServiceSubscriptionListList{},
 		&Sidecar{},
 		&SidecarList{},
 		&VirtualService{},
diff --git a/pkg/apis/networking/v1alpha3/types.gen.go b/pkg/apis/networking/v1alpha3/types.gen.go
index 6acf50e..34ebd94 100644
--- a/pkg/apis/networking/v1alpha3/types.gen.go
+++ b/pkg/apis/networking/v1alpha3/types.gen.go
@@ -232,6 +232,49 @@ type ServiceEntryList struct {
 //
 // +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
 
+// <!-- crd generation tags
+// +cue-gen:ServiceSubscriptionList:groupName:networking.istio.io
+// +cue-gen:ServiceSubscriptionList:version:v1alpha3
+// +cue-gen:ServiceSubscriptionList:storageVersion
+// +cue-gen:ServiceSubscriptionList:annotations:helm.sh/resource-policy=keep
+// +cue-gen:ServiceSubscriptionList:labels:app=istio-pilot,chart=istio,heritage=Tiller,release=istio
+// +cue-gen:ServiceSubscriptionList:subresource:status
+// +cue-gen:ServiceSubscriptionList:scope:Namespaced
+// +cue-gen:ServiceSubscriptionList:resource:categories=istio-io,networking-istio-io
+// +cue-gen:ServiceSubscriptionList:preserveUnknownFields:false
+// -->
+//
+// <!-- go code generation tags
+// +kubetype-gen
+// +kubetype-gen:groupVersion=networking.istio.io/v1alpha3
+// +genclient
+// +k8s:deepcopy-gen=true
+// -->
+type ServiceSubscriptionList struct {
+	v1.TypeMeta `json:",inline"`
+	// +optional
+	v1.ObjectMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
+
+	// Spec defines the implementation of this definition.
+	// +optional
+	Spec networkingv1alpha3.ServiceSubscriptionList `json:"spec,omitempty" protobuf:"bytes,2,opt,name=spec"`
+
+	Status v1alpha1.IstioStatus `json:"status"`
+}
+
+// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
+
+// ServiceSubscriptionListList is a collection of ServiceSubscriptionLists.
+type ServiceSubscriptionListList struct {
+	v1.TypeMeta `json:",inline"`
+	// +optional
+	v1.ListMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
+	Items       []ServiceSubscriptionList `json:"items" protobuf:"bytes,2,rep,name=items"`
+}
+
+//
+// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
+
 // `Sidecar` describes the configuration of the sidecar proxy that mediates
 // inbound and outbound communication of the workload instance to which it is
 // attached.
diff --git a/pkg/apis/networking/v1alpha3/zz_generated.deepcopy.gen.go b/pkg/apis/networking/v1alpha3/zz_generated.deepcopy.gen.go
index b95f8fc..126f013 100644
--- a/pkg/apis/networking/v1alpha3/zz_generated.deepcopy.gen.go
+++ b/pkg/apis/networking/v1alpha3/zz_generated.deepcopy.gen.go
@@ -267,6 +267,67 @@ func (in *ServiceEntryList) DeepCopyObject() runtime.Object {
 	return nil
 }
 
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *ServiceSubscriptionList) DeepCopyInto(out *ServiceSubscriptionList) {
+	*out = *in
+	out.TypeMeta = in.TypeMeta
+	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
+	in.Spec.DeepCopyInto(&out.Spec)
+	in.Status.DeepCopyInto(&out.Status)
+	return
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceSubscriptionList.
+func (in *ServiceSubscriptionList) DeepCopy() *ServiceSubscriptionList {
+	if in == nil {
+		return nil
+	}
+	out := new(ServiceSubscriptionList)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
+func (in *ServiceSubscriptionList) DeepCopyObject() runtime.Object {
+	if c := in.DeepCopy(); c != nil {
+		return c
+	}
+	return nil
+}
+
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *ServiceSubscriptionListList) DeepCopyInto(out *ServiceSubscriptionListList) {
+	*out = *in
+	out.TypeMeta = in.TypeMeta
+	in.ListMeta.DeepCopyInto(&out.ListMeta)
+	if in.Items != nil {
+		in, out := &in.Items, &out.Items
+		*out = make([]ServiceSubscriptionList, len(*in))
+		for i := range *in {
+			(*in)[i].DeepCopyInto(&(*out)[i])
+		}
+	}
+	return
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceSubscriptionListList.
+func (in *ServiceSubscriptionListList) DeepCopy() *ServiceSubscriptionListList {
+	if in == nil {
+		return nil
+	}
+	out := new(ServiceSubscriptionListList)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
+func (in *ServiceSubscriptionListList) DeepCopyObject() runtime.Object {
+	if c := in.DeepCopy(); c != nil {
+		return c
+	}
+	return nil
+}
+
 // DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
 func (in *Sidecar) DeepCopyInto(out *Sidecar) {
 	*out = *in
diff --git a/pkg/apis/networking/v1beta1/register.gen.go b/pkg/apis/networking/v1beta1/register.gen.go
index 153ef30..f045bb9 100644
--- a/pkg/apis/networking/v1beta1/register.gen.go
+++ b/pkg/apis/networking/v1beta1/register.gen.go
@@ -47,6 +47,8 @@ func addKnownTypes(scheme *runtime.Scheme) error {
 		&GatewayList{},
 		&ServiceEntry{},
 		&ServiceEntryList{},
+		&ServiceSubscriptionList{},
+		&ServiceSubscriptionListList{},
 		&Sidecar{},
 		&SidecarList{},
 		&VirtualService{},
diff --git a/pkg/apis/networking/v1beta1/types.gen.go b/pkg/apis/networking/v1beta1/types.gen.go
index 7cd2b88..c798247 100644
--- a/pkg/apis/networking/v1beta1/types.gen.go
+++ b/pkg/apis/networking/v1beta1/types.gen.go
@@ -183,6 +183,49 @@ type ServiceEntryList struct {
 //
 // +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
 
+// <!-- crd generation tags
+// +cue-gen:ServiceSubscriptionList:groupName:networking.istio.io
+// +cue-gen:ServiceSubscriptionList:version:v1beta1
+// +cue-gen:ServiceSubscriptionList:storageVersion
+// +cue-gen:ServiceSubscriptionList:annotations:helm.sh/resource-policy=keep
+// +cue-gen:ServiceSubscriptionList:labels:app=istio-pilot,chart=istio,heritage=Tiller,release=istio
+// +cue-gen:ServiceSubscriptionList:subresource:status
+// +cue-gen:ServiceSubscriptionList:scope:Namespaced
+// +cue-gen:ServiceSubscriptionList:resource:categories=istio-io,networking-istio-io
+// +cue-gen:ServiceSubscriptionList:preserveUnknownFields:false
+// -->
+//
+// <!-- go code generation tags
+// +kubetype-gen
+// +kubetype-gen:groupVersion=networking.istio.io/v1beta1
+// +genclient
+// +k8s:deepcopy-gen=true
+// -->
+type ServiceSubscriptionList struct {
+	v1.TypeMeta `json:",inline"`
+	// +optional
+	v1.ObjectMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
+
+	// Spec defines the implementation of this definition.
+	// +optional
+	Spec networkingv1beta1.ServiceSubscriptionList `json:"spec,omitempty" protobuf:"bytes,2,opt,name=spec"`
+
+	Status v1alpha1.IstioStatus `json:"status"`
+}
+
+// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
+
+// ServiceSubscriptionListList is a collection of ServiceSubscriptionLists.
+type ServiceSubscriptionListList struct {
+	v1.TypeMeta `json:",inline"`
+	// +optional
+	v1.ListMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
+	Items       []ServiceSubscriptionList `json:"items" protobuf:"bytes,2,rep,name=items"`
+}
+
+//
+// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
+
 // `Sidecar` describes the configuration of the sidecar proxy that mediates
 // inbound and outbound communication of the workload instance to which it is
 // attached.
diff --git a/pkg/apis/networking/v1beta1/zz_generated.deepcopy.gen.go b/pkg/apis/networking/v1beta1/zz_generated.deepcopy.gen.go
index 4b9121c..67f43f0 100644
--- a/pkg/apis/networking/v1beta1/zz_generated.deepcopy.gen.go
+++ b/pkg/apis/networking/v1beta1/zz_generated.deepcopy.gen.go
@@ -206,6 +206,67 @@ func (in *ServiceEntryList) DeepCopyObject() runtime.Object {
 	return nil
 }
 
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *ServiceSubscriptionList) DeepCopyInto(out *ServiceSubscriptionList) {
+	*out = *in
+	out.TypeMeta = in.TypeMeta
+	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
+	in.Spec.DeepCopyInto(&out.Spec)
+	in.Status.DeepCopyInto(&out.Status)
+	return
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceSubscriptionList.
+func (in *ServiceSubscriptionList) DeepCopy() *ServiceSubscriptionList {
+	if in == nil {
+		return nil
+	}
+	out := new(ServiceSubscriptionList)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
+func (in *ServiceSubscriptionList) DeepCopyObject() runtime.Object {
+	if c := in.DeepCopy(); c != nil {
+		return c
+	}
+	return nil
+}
+
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *ServiceSubscriptionListList) DeepCopyInto(out *ServiceSubscriptionListList) {
+	*out = *in
+	out.TypeMeta = in.TypeMeta
+	in.ListMeta.DeepCopyInto(&out.ListMeta)
+	if in.Items != nil {
+		in, out := &in.Items, &out.Items
+		*out = make([]ServiceSubscriptionList, len(*in))
+		for i := range *in {
+			(*in)[i].DeepCopyInto(&(*out)[i])
+		}
+	}
+	return
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServiceSubscriptionListList.
+func (in *ServiceSubscriptionListList) DeepCopy() *ServiceSubscriptionListList {
+	if in == nil {
+		return nil
+	}
+	out := new(ServiceSubscriptionListList)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
+func (in *ServiceSubscriptionListList) DeepCopyObject() runtime.Object {
+	if c := in.DeepCopy(); c != nil {
+		return c
+	}
+	return nil
+}
+
 // DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
 func (in *Sidecar) DeepCopyInto(out *Sidecar) {
 	*out = *in
diff --git a/pkg/clientset/versioned/typed/networking/v1alpha3/fake/fake_networking_client.gen.go b/pkg/clientset/versioned/typed/networking/v1alpha3/fake/fake_networking_client.gen.go
index 180f8aa..564a04d 100644
--- a/pkg/clientset/versioned/typed/networking/v1alpha3/fake/fake_networking_client.gen.go
+++ b/pkg/clientset/versioned/typed/networking/v1alpha3/fake/fake_networking_client.gen.go
@@ -42,6 +42,10 @@ func (c *FakeNetworkingV1alpha3) ServiceEntries(namespace string) v1alpha3.Servi
 	return &FakeServiceEntries{c, namespace}
 }
 
+func (c *FakeNetworkingV1alpha3) ServiceSubscriptionLists(namespace string) v1alpha3.ServiceSubscriptionListInterface {
+	return &FakeServiceSubscriptionLists{c, namespace}
+}
+
 func (c *FakeNetworkingV1alpha3) Sidecars(namespace string) v1alpha3.SidecarInterface {
 	return &FakeSidecars{c, namespace}
 }
diff --git a/pkg/clientset/versioned/typed/networking/v1alpha3/fake/fake_servicesubscriptionlist.gen.go b/pkg/clientset/versioned/typed/networking/v1alpha3/fake/fake_servicesubscriptionlist.gen.go
new file mode 100644
index 0000000..3d544f6
--- /dev/null
+++ b/pkg/clientset/versioned/typed/networking/v1alpha3/fake/fake_servicesubscriptionlist.gen.go
@@ -0,0 +1,140 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// Code generated by client-gen. DO NOT EDIT.
+
+package fake
+
+import (
+	"context"
+
+	v1alpha3 "istio.io/client-go/pkg/apis/networking/v1alpha3"
+	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	labels "k8s.io/apimachinery/pkg/labels"
+	schema "k8s.io/apimachinery/pkg/runtime/schema"
+	types "k8s.io/apimachinery/pkg/types"
+	watch "k8s.io/apimachinery/pkg/watch"
+	testing "k8s.io/client-go/testing"
+)
+
+// FakeServiceSubscriptionLists implements ServiceSubscriptionListInterface
+type FakeServiceSubscriptionLists struct {
+	Fake *FakeNetworkingV1alpha3
+	ns   string
+}
+
+var servicesubscriptionlistsResource = schema.GroupVersionResource{Group: "networking.istio.io", Version: "v1alpha3", Resource: "servicesubscriptionlists"}
+
+var servicesubscriptionlistsKind = schema.GroupVersionKind{Group: "networking.istio.io", Version: "v1alpha3", Kind: "ServiceSubscriptionList"}
+
+// Get takes name of the serviceSubscriptionList, and returns the corresponding serviceSubscriptionList object, and an error if there is any.
+func (c *FakeServiceSubscriptionLists) Get(ctx context.Context, name string, options v1.GetOptions) (result *v1alpha3.ServiceSubscriptionList, err error) {
+	obj, err := c.Fake.
+		Invokes(testing.NewGetAction(servicesubscriptionlistsResource, c.ns, name), &v1alpha3.ServiceSubscriptionList{})
+
+	if obj == nil {
+		return nil, err
+	}
+	return obj.(*v1alpha3.ServiceSubscriptionList), err
+}
+
+// List takes label and field selectors, and returns the list of ServiceSubscriptionLists that match those selectors.
+func (c *FakeServiceSubscriptionLists) List(ctx context.Context, opts v1.ListOptions) (result *v1alpha3.ServiceSubscriptionListList, err error) {
+	obj, err := c.Fake.
+		Invokes(testing.NewListAction(servicesubscriptionlistsResource, servicesubscriptionlistsKind, c.ns, opts), &v1alpha3.ServiceSubscriptionListList{})
+
+	if obj == nil {
+		return nil, err
+	}
+
+	label, _, _ := testing.ExtractFromListOptions(opts)
+	if label == nil {
+		label = labels.Everything()
+	}
+	list := &v1alpha3.ServiceSubscriptionListList{ListMeta: obj.(*v1alpha3.ServiceSubscriptionListList).ListMeta}
+	for _, item := range obj.(*v1alpha3.ServiceSubscriptionListList).Items {
+		if label.Matches(labels.Set(item.Labels)) {
+			list.Items = append(list.Items, item)
+		}
+	}
+	return list, err
+}
+
+// Watch returns a watch.Interface that watches the requested serviceSubscriptionLists.
+func (c *FakeServiceSubscriptionLists) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
+	return c.Fake.
+		InvokesWatch(testing.NewWatchAction(servicesubscriptionlistsResource, c.ns, opts))
+
+}
+
+// Create takes the representation of a serviceSubscriptionList and creates it.  Returns the server's representation of the serviceSubscriptionList, and an error, if there is any.
+func (c *FakeServiceSubscriptionLists) Create(ctx context.Context, serviceSubscriptionList *v1alpha3.ServiceSubscriptionList, opts v1.CreateOptions) (result *v1alpha3.ServiceSubscriptionList, err error) {
+	obj, err := c.Fake.
+		Invokes(testing.NewCreateAction(servicesubscriptionlistsResource, c.ns, serviceSubscriptionList), &v1alpha3.ServiceSubscriptionList{})
+
+	if obj == nil {
+		return nil, err
+	}
+	return obj.(*v1alpha3.ServiceSubscriptionList), err
+}
+
+// Update takes the representation of a serviceSubscriptionList and updates it. Returns the server's representation of the serviceSubscriptionList, and an error, if there is any.
+func (c *FakeServiceSubscriptionLists) Update(ctx context.Context, serviceSubscriptionList *v1alpha3.ServiceSubscriptionList, opts v1.UpdateOptions) (result *v1alpha3.ServiceSubscriptionList, err error) {
+	obj, err := c.Fake.
+		Invokes(testing.NewUpdateAction(servicesubscriptionlistsResource, c.ns, serviceSubscriptionList), &v1alpha3.ServiceSubscriptionList{})
+
+	if obj == nil {
+		return nil, err
+	}
+	return obj.(*v1alpha3.ServiceSubscriptionList), err
+}
+
+// UpdateStatus was generated because the type contains a Status member.
+// Add a +genclient:noStatus comment above the type to avoid generating UpdateStatus().
+func (c *FakeServiceSubscriptionLists) UpdateStatus(ctx context.Context, serviceSubscriptionList *v1alpha3.ServiceSubscriptionList, opts v1.UpdateOptions) (*v1alpha3.ServiceSubscriptionList, error) {
+	obj, err := c.Fake.
+		Invokes(testing.NewUpdateSubresourceAction(servicesubscriptionlistsResource, "status", c.ns, serviceSubscriptionList), &v1alpha3.ServiceSubscriptionList{})
+
+	if obj == nil {
+		return nil, err
+	}
+	return obj.(*v1alpha3.ServiceSubscriptionList), err
+}
+
+// Delete takes name of the serviceSubscriptionList and deletes it. Returns an error if one occurs.
+func (c *FakeServiceSubscriptionLists) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
+	_, err := c.Fake.
+		Invokes(testing.NewDeleteAction(servicesubscriptionlistsResource, c.ns, name), &v1alpha3.ServiceSubscriptionList{})
+
+	return err
+}
+
+// DeleteCollection deletes a collection of objects.
+func (c *FakeServiceSubscriptionLists) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
+	action := testing.NewDeleteCollectionAction(servicesubscriptionlistsResource, c.ns, listOpts)
+
+	_, err := c.Fake.Invokes(action, &v1alpha3.ServiceSubscriptionListList{})
+	return err
+}
+
+// Patch applies the patch and returns the patched serviceSubscriptionList.
+func (c *FakeServiceSubscriptionLists) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *v1alpha3.ServiceSubscriptionList, err error) {
+	obj, err := c.Fake.
+		Invokes(testing.NewPatchSubresourceAction(servicesubscriptionlistsResource, c.ns, name, pt, data, subresources...), &v1alpha3.ServiceSubscriptionList{})
+
+	if obj == nil {
+		return nil, err
+	}
+	return obj.(*v1alpha3.ServiceSubscriptionList), err
+}
diff --git a/pkg/clientset/versioned/typed/networking/v1alpha3/generated_expansion.gen.go b/pkg/clientset/versioned/typed/networking/v1alpha3/generated_expansion.gen.go
index 8812087..ef07c75 100644
--- a/pkg/clientset/versioned/typed/networking/v1alpha3/generated_expansion.gen.go
+++ b/pkg/clientset/versioned/typed/networking/v1alpha3/generated_expansion.gen.go
@@ -24,6 +24,8 @@ type GatewayExpansion interface{}
 
 type ServiceEntryExpansion interface{}
 
+type ServiceSubscriptionListExpansion interface{}
+
 type SidecarExpansion interface{}
 
 type VirtualServiceExpansion interface{}
diff --git a/pkg/clientset/versioned/typed/networking/v1alpha3/networking_client.gen.go b/pkg/clientset/versioned/typed/networking/v1alpha3/networking_client.gen.go
index 4476c44..0444a57 100644
--- a/pkg/clientset/versioned/typed/networking/v1alpha3/networking_client.gen.go
+++ b/pkg/clientset/versioned/typed/networking/v1alpha3/networking_client.gen.go
@@ -28,6 +28,7 @@ type NetworkingV1alpha3Interface interface {
 	EnvoyFiltersGetter
 	GatewaysGetter
 	ServiceEntriesGetter
+	ServiceSubscriptionListsGetter
 	SidecarsGetter
 	VirtualServicesGetter
 	WorkloadEntriesGetter
@@ -55,6 +56,10 @@ func (c *NetworkingV1alpha3Client) ServiceEntries(namespace string) ServiceEntry
 	return newServiceEntries(c, namespace)
 }
 
+func (c *NetworkingV1alpha3Client) ServiceSubscriptionLists(namespace string) ServiceSubscriptionListInterface {
+	return newServiceSubscriptionLists(c, namespace)
+}
+
 func (c *NetworkingV1alpha3Client) Sidecars(namespace string) SidecarInterface {
 	return newSidecars(c, namespace)
 }
diff --git a/pkg/clientset/versioned/typed/networking/v1alpha3/servicesubscriptionlist.gen.go b/pkg/clientset/versioned/typed/networking/v1alpha3/servicesubscriptionlist.gen.go
new file mode 100644
index 0000000..bf1639e
--- /dev/null
+++ b/pkg/clientset/versioned/typed/networking/v1alpha3/servicesubscriptionlist.gen.go
@@ -0,0 +1,193 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// Code generated by client-gen. DO NOT EDIT.
+
+package v1alpha3
+
+import (
+	"context"
+	"time"
+
+	v1alpha3 "istio.io/client-go/pkg/apis/networking/v1alpha3"
+	scheme "istio.io/client-go/pkg/clientset/versioned/scheme"
+	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	types "k8s.io/apimachinery/pkg/types"
+	watch "k8s.io/apimachinery/pkg/watch"
+	rest "k8s.io/client-go/rest"
+)
+
+// ServiceSubscriptionListsGetter has a method to return a ServiceSubscriptionListInterface.
+// A group's client should implement this interface.
+type ServiceSubscriptionListsGetter interface {
+	ServiceSubscriptionLists(namespace string) ServiceSubscriptionListInterface
+}
+
+// ServiceSubscriptionListInterface has methods to work with ServiceSubscriptionList resources.
+type ServiceSubscriptionListInterface interface {
+	Create(ctx context.Context, serviceSubscriptionList *v1alpha3.ServiceSubscriptionList, opts v1.CreateOptions) (*v1alpha3.ServiceSubscriptionList, error)
+	Update(ctx context.Context, serviceSubscriptionList *v1alpha3.ServiceSubscriptionList, opts v1.UpdateOptions) (*v1alpha3.ServiceSubscriptionList, error)
+	UpdateStatus(ctx context.Context, serviceSubscriptionList *v1alpha3.ServiceSubscriptionList, opts v1.UpdateOptions) (*v1alpha3.ServiceSubscriptionList, error)
+	Delete(ctx context.Context, name string, opts v1.DeleteOptions) error
+	DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error
+	Get(ctx context.Context, name string, opts v1.GetOptions) (*v1alpha3.ServiceSubscriptionList, error)
+	List(ctx context.Context, opts v1.ListOptions) (*v1alpha3.ServiceSubscriptionListList, error)
+	Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error)
+	Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *v1alpha3.ServiceSubscriptionList, err error)
+	ServiceSubscriptionListExpansion
+}
+
+// serviceSubscriptionLists implements ServiceSubscriptionListInterface
+type serviceSubscriptionLists struct {
+	client rest.Interface
+	ns     string
+}
+
+// newServiceSubscriptionLists returns a ServiceSubscriptionLists
+func newServiceSubscriptionLists(c *NetworkingV1alpha3Client, namespace string) *serviceSubscriptionLists {
+	return &serviceSubscriptionLists{
+		client: c.RESTClient(),
+		ns:     namespace,
+	}
+}
+
+// Get takes name of the serviceSubscriptionList, and returns the corresponding serviceSubscriptionList object, and an error if there is any.
+func (c *serviceSubscriptionLists) Get(ctx context.Context, name string, options v1.GetOptions) (result *v1alpha3.ServiceSubscriptionList, err error) {
+	result = &v1alpha3.ServiceSubscriptionList{}
+	err = c.client.Get().
+		Namespace(c.ns).
+		Resource("servicesubscriptionlists").
+		Name(name).
+		VersionedParams(&options, scheme.ParameterCodec).
+		Do(ctx).
+		Into(result)
+	return
+}
+
+// List takes label and field selectors, and returns the list of ServiceSubscriptionLists that match those selectors.
+func (c *serviceSubscriptionLists) List(ctx context.Context, opts v1.ListOptions) (result *v1alpha3.ServiceSubscriptionListList, err error) {
+	var timeout time.Duration
+	if opts.TimeoutSeconds != nil {
+		timeout = time.Duration(*opts.TimeoutSeconds) * time.Second
+	}
+	result = &v1alpha3.ServiceSubscriptionListList{}
+	err = c.client.Get().
+		Namespace(c.ns).
+		Resource("servicesubscriptionlists").
+		VersionedParams(&opts, scheme.ParameterCodec).
+		Timeout(timeout).
+		Do(ctx).
+		Into(result)
+	return
+}
+
+// Watch returns a watch.Interface that watches the requested serviceSubscriptionLists.
+func (c *serviceSubscriptionLists) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
+	var timeout time.Duration
+	if opts.TimeoutSeconds != nil {
+		timeout = time.Duration(*opts.TimeoutSeconds) * time.Second
+	}
+	opts.Watch = true
+	return c.client.Get().
+		Namespace(c.ns).
+		Resource("servicesubscriptionlists").
+		VersionedParams(&opts, scheme.ParameterCodec).
+		Timeout(timeout).
+		Watch(ctx)
+}
+
+// Create takes the representation of a serviceSubscriptionList and creates it.  Returns the server's representation of the serviceSubscriptionList, and an error, if there is any.
+func (c *serviceSubscriptionLists) Create(ctx context.Context, serviceSubscriptionList *v1alpha3.ServiceSubscriptionList, opts v1.CreateOptions) (result *v1alpha3.ServiceSubscriptionList, err error) {
+	result = &v1alpha3.ServiceSubscriptionList{}
+	err = c.client.Post().
+		Namespace(c.ns).
+		Resource("servicesubscriptionlists").
+		VersionedParams(&opts, scheme.ParameterCodec).
+		Body(serviceSubscriptionList).
+		Do(ctx).
+		Into(result)
+	return
+}
+
+// Update takes the representation of a serviceSubscriptionList and updates it. Returns the server's representation of the serviceSubscriptionList, and an error, if there is any.
+func (c *serviceSubscriptionLists) Update(ctx context.Context, serviceSubscriptionList *v1alpha3.ServiceSubscriptionList, opts v1.UpdateOptions) (result *v1alpha3.ServiceSubscriptionList, err error) {
+	result = &v1alpha3.ServiceSubscriptionList{}
+	err = c.client.Put().
+		Namespace(c.ns).
+		Resource("servicesubscriptionlists").
+		Name(serviceSubscriptionList.Name).
+		VersionedParams(&opts, scheme.ParameterCodec).
+		Body(serviceSubscriptionList).
+		Do(ctx).
+		Into(result)
+	return
+}
+
+// UpdateStatus was generated because the type contains a Status member.
+// Add a +genclient:noStatus comment above the type to avoid generating UpdateStatus().
+func (c *serviceSubscriptionLists) UpdateStatus(ctx context.Context, serviceSubscriptionList *v1alpha3.ServiceSubscriptionList, opts v1.UpdateOptions) (result *v1alpha3.ServiceSubscriptionList, err error) {
+	result = &v1alpha3.ServiceSubscriptionList{}
+	err = c.client.Put().
+		Namespace(c.ns).
+		Resource("servicesubscriptionlists").
+		Name(serviceSubscriptionList.Name).
+		SubResource("status").
+		VersionedParams(&opts, scheme.ParameterCodec).
+		Body(serviceSubscriptionList).
+		Do(ctx).
+		Into(result)
+	return
+}
+
+// Delete takes name of the serviceSubscriptionList and deletes it. Returns an error if one occurs.
+func (c *serviceSubscriptionLists) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
+	return c.client.Delete().
+		Namespace(c.ns).
+		Resource("servicesubscriptionlists").
+		Name(name).
+		Body(&opts).
+		Do(ctx).
+		Error()
+}
+
+// DeleteCollection deletes a collection of objects.
+func (c *serviceSubscriptionLists) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
+	var timeout time.Duration
+	if listOpts.TimeoutSeconds != nil {
+		timeout = time.Duration(*listOpts.TimeoutSeconds) * time.Second
+	}
+	return c.client.Delete().
+		Namespace(c.ns).
+		Resource("servicesubscriptionlists").
+		VersionedParams(&listOpts, scheme.ParameterCodec).
+		Timeout(timeout).
+		Body(&opts).
+		Do(ctx).
+		Error()
+}
+
+// Patch applies the patch and returns the patched serviceSubscriptionList.
+func (c *serviceSubscriptionLists) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *v1alpha3.ServiceSubscriptionList, err error) {
+	result = &v1alpha3.ServiceSubscriptionList{}
+	err = c.client.Patch(pt).
+		Namespace(c.ns).
+		Resource("servicesubscriptionlists").
+		Name(name).
+		SubResource(subresources...).
+		VersionedParams(&opts, scheme.ParameterCodec).
+		Body(data).
+		Do(ctx).
+		Into(result)
+	return
+}
diff --git a/pkg/clientset/versioned/typed/networking/v1beta1/fake/fake_networking_client.gen.go b/pkg/clientset/versioned/typed/networking/v1beta1/fake/fake_networking_client.gen.go
index 522e51d..4ce33b3 100644
--- a/pkg/clientset/versioned/typed/networking/v1beta1/fake/fake_networking_client.gen.go
+++ b/pkg/clientset/versioned/typed/networking/v1beta1/fake/fake_networking_client.gen.go
@@ -38,6 +38,10 @@ func (c *FakeNetworkingV1beta1) ServiceEntries(namespace string) v1beta1.Service
 	return &FakeServiceEntries{c, namespace}
 }
 
+func (c *FakeNetworkingV1beta1) ServiceSubscriptionLists(namespace string) v1beta1.ServiceSubscriptionListInterface {
+	return &FakeServiceSubscriptionLists{c, namespace}
+}
+
 func (c *FakeNetworkingV1beta1) Sidecars(namespace string) v1beta1.SidecarInterface {
 	return &FakeSidecars{c, namespace}
 }
diff --git a/pkg/clientset/versioned/typed/networking/v1beta1/fake/fake_servicesubscriptionlist.gen.go b/pkg/clientset/versioned/typed/networking/v1beta1/fake/fake_servicesubscriptionlist.gen.go
new file mode 100644
index 0000000..0f24dca
--- /dev/null
+++ b/pkg/clientset/versioned/typed/networking/v1beta1/fake/fake_servicesubscriptionlist.gen.go
@@ -0,0 +1,140 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// Code generated by client-gen. DO NOT EDIT.
+
+package fake
+
+import (
+	"context"
+
+	v1beta1 "istio.io/client-go/pkg/apis/networking/v1beta1"
+	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	labels "k8s.io/apimachinery/pkg/labels"
+	schema "k8s.io/apimachinery/pkg/runtime/schema"
+	types "k8s.io/apimachinery/pkg/types"
+	watch "k8s.io/apimachinery/pkg/watch"
+	testing "k8s.io/client-go/testing"
+)
+
+// FakeServiceSubscriptionLists implements ServiceSubscriptionListInterface
+type FakeServiceSubscriptionLists struct {
+	Fake *FakeNetworkingV1beta1
+	ns   string
+}
+
+var servicesubscriptionlistsResource = schema.GroupVersionResource{Group: "networking.istio.io", Version: "v1beta1", Resource: "servicesubscriptionlists"}
+
+var servicesubscriptionlistsKind = schema.GroupVersionKind{Group: "networking.istio.io", Version: "v1beta1", Kind: "ServiceSubscriptionList"}
+
+// Get takes name of the serviceSubscriptionList, and returns the corresponding serviceSubscriptionList object, and an error if there is any.
+func (c *FakeServiceSubscriptionLists) Get(ctx context.Context, name string, options v1.GetOptions) (result *v1beta1.ServiceSubscriptionList, err error) {
+	obj, err := c.Fake.
+		Invokes(testing.NewGetAction(servicesubscriptionlistsResource, c.ns, name), &v1beta1.ServiceSubscriptionList{})
+
+	if obj == nil {
+		return nil, err
+	}
+	return obj.(*v1beta1.ServiceSubscriptionList), err
+}
+
+// List takes label and field selectors, and returns the list of ServiceSubscriptionLists that match those selectors.
+func (c *FakeServiceSubscriptionLists) List(ctx context.Context, opts v1.ListOptions) (result *v1beta1.ServiceSubscriptionListList, err error) {
+	obj, err := c.Fake.
+		Invokes(testing.NewListAction(servicesubscriptionlistsResource, servicesubscriptionlistsKind, c.ns, opts), &v1beta1.ServiceSubscriptionListList{})
+
+	if obj == nil {
+		return nil, err
+	}
+
+	label, _, _ := testing.ExtractFromListOptions(opts)
+	if label == nil {
+		label = labels.Everything()
+	}
+	list := &v1beta1.ServiceSubscriptionListList{ListMeta: obj.(*v1beta1.ServiceSubscriptionListList).ListMeta}
+	for _, item := range obj.(*v1beta1.ServiceSubscriptionListList).Items {
+		if label.Matches(labels.Set(item.Labels)) {
+			list.Items = append(list.Items, item)
+		}
+	}
+	return list, err
+}
+
+// Watch returns a watch.Interface that watches the requested serviceSubscriptionLists.
+func (c *FakeServiceSubscriptionLists) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
+	return c.Fake.
+		InvokesWatch(testing.NewWatchAction(servicesubscriptionlistsResource, c.ns, opts))
+
+}
+
+// Create takes the representation of a serviceSubscriptionList and creates it.  Returns the server's representation of the serviceSubscriptionList, and an error, if there is any.
+func (c *FakeServiceSubscriptionLists) Create(ctx context.Context, serviceSubscriptionList *v1beta1.ServiceSubscriptionList, opts v1.CreateOptions) (result *v1beta1.ServiceSubscriptionList, err error) {
+	obj, err := c.Fake.
+		Invokes(testing.NewCreateAction(servicesubscriptionlistsResource, c.ns, serviceSubscriptionList), &v1beta1.ServiceSubscriptionList{})
+
+	if obj == nil {
+		return nil, err
+	}
+	return obj.(*v1beta1.ServiceSubscriptionList), err
+}
+
+// Update takes the representation of a serviceSubscriptionList and updates it. Returns the server's representation of the serviceSubscriptionList, and an error, if there is any.
+func (c *FakeServiceSubscriptionLists) Update(ctx context.Context, serviceSubscriptionList *v1beta1.ServiceSubscriptionList, opts v1.UpdateOptions) (result *v1beta1.ServiceSubscriptionList, err error) {
+	obj, err := c.Fake.
+		Invokes(testing.NewUpdateAction(servicesubscriptionlistsResource, c.ns, serviceSubscriptionList), &v1beta1.ServiceSubscriptionList{})
+
+	if obj == nil {
+		return nil, err
+	}
+	return obj.(*v1beta1.ServiceSubscriptionList), err
+}
+
+// UpdateStatus was generated because the type contains a Status member.
+// Add a +genclient:noStatus comment above the type to avoid generating UpdateStatus().
+func (c *FakeServiceSubscriptionLists) UpdateStatus(ctx context.Context, serviceSubscriptionList *v1beta1.ServiceSubscriptionList, opts v1.UpdateOptions) (*v1beta1.ServiceSubscriptionList, error) {
+	obj, err := c.Fake.
+		Invokes(testing.NewUpdateSubresourceAction(servicesubscriptionlistsResource, "status", c.ns, serviceSubscriptionList), &v1beta1.ServiceSubscriptionList{})
+
+	if obj == nil {
+		return nil, err
+	}
+	return obj.(*v1beta1.ServiceSubscriptionList), err
+}
+
+// Delete takes name of the serviceSubscriptionList and deletes it. Returns an error if one occurs.
+func (c *FakeServiceSubscriptionLists) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
+	_, err := c.Fake.
+		Invokes(testing.NewDeleteAction(servicesubscriptionlistsResource, c.ns, name), &v1beta1.ServiceSubscriptionList{})
+
+	return err
+}
+
+// DeleteCollection deletes a collection of objects.
+func (c *FakeServiceSubscriptionLists) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
+	action := testing.NewDeleteCollectionAction(servicesubscriptionlistsResource, c.ns, listOpts)
+
+	_, err := c.Fake.Invokes(action, &v1beta1.ServiceSubscriptionListList{})
+	return err
+}
+
+// Patch applies the patch and returns the patched serviceSubscriptionList.
+func (c *FakeServiceSubscriptionLists) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *v1beta1.ServiceSubscriptionList, err error) {
+	obj, err := c.Fake.
+		Invokes(testing.NewPatchSubresourceAction(servicesubscriptionlistsResource, c.ns, name, pt, data, subresources...), &v1beta1.ServiceSubscriptionList{})
+
+	if obj == nil {
+		return nil, err
+	}
+	return obj.(*v1beta1.ServiceSubscriptionList), err
+}
diff --git a/pkg/clientset/versioned/typed/networking/v1beta1/generated_expansion.gen.go b/pkg/clientset/versioned/typed/networking/v1beta1/generated_expansion.gen.go
index f30b89e..637f1eb 100644
--- a/pkg/clientset/versioned/typed/networking/v1beta1/generated_expansion.gen.go
+++ b/pkg/clientset/versioned/typed/networking/v1beta1/generated_expansion.gen.go
@@ -22,6 +22,8 @@ type GatewayExpansion interface{}
 
 type ServiceEntryExpansion interface{}
 
+type ServiceSubscriptionListExpansion interface{}
+
 type SidecarExpansion interface{}
 
 type VirtualServiceExpansion interface{}
diff --git a/pkg/clientset/versioned/typed/networking/v1beta1/networking_client.gen.go b/pkg/clientset/versioned/typed/networking/v1beta1/networking_client.gen.go
index 59d206b..2ddd122 100644
--- a/pkg/clientset/versioned/typed/networking/v1beta1/networking_client.gen.go
+++ b/pkg/clientset/versioned/typed/networking/v1beta1/networking_client.gen.go
@@ -27,6 +27,7 @@ type NetworkingV1beta1Interface interface {
 	DestinationRulesGetter
 	GatewaysGetter
 	ServiceEntriesGetter
+	ServiceSubscriptionListsGetter
 	SidecarsGetter
 	VirtualServicesGetter
 	WorkloadEntriesGetter
@@ -49,6 +50,10 @@ func (c *NetworkingV1beta1Client) ServiceEntries(namespace string) ServiceEntryI
 	return newServiceEntries(c, namespace)
 }
 
+func (c *NetworkingV1beta1Client) ServiceSubscriptionLists(namespace string) ServiceSubscriptionListInterface {
+	return newServiceSubscriptionLists(c, namespace)
+}
+
 func (c *NetworkingV1beta1Client) Sidecars(namespace string) SidecarInterface {
 	return newSidecars(c, namespace)
 }
diff --git a/pkg/clientset/versioned/typed/networking/v1beta1/servicesubscriptionlist.gen.go b/pkg/clientset/versioned/typed/networking/v1beta1/servicesubscriptionlist.gen.go
new file mode 100644
index 0000000..9a18f9f
--- /dev/null
+++ b/pkg/clientset/versioned/typed/networking/v1beta1/servicesubscriptionlist.gen.go
@@ -0,0 +1,193 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// Code generated by client-gen. DO NOT EDIT.
+
+package v1beta1
+
+import (
+	"context"
+	"time"
+
+	v1beta1 "istio.io/client-go/pkg/apis/networking/v1beta1"
+	scheme "istio.io/client-go/pkg/clientset/versioned/scheme"
+	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	types "k8s.io/apimachinery/pkg/types"
+	watch "k8s.io/apimachinery/pkg/watch"
+	rest "k8s.io/client-go/rest"
+)
+
+// ServiceSubscriptionListsGetter has a method to return a ServiceSubscriptionListInterface.
+// A group's client should implement this interface.
+type ServiceSubscriptionListsGetter interface {
+	ServiceSubscriptionLists(namespace string) ServiceSubscriptionListInterface
+}
+
+// ServiceSubscriptionListInterface has methods to work with ServiceSubscriptionList resources.
+type ServiceSubscriptionListInterface interface {
+	Create(ctx context.Context, serviceSubscriptionList *v1beta1.ServiceSubscriptionList, opts v1.CreateOptions) (*v1beta1.ServiceSubscriptionList, error)
+	Update(ctx context.Context, serviceSubscriptionList *v1beta1.ServiceSubscriptionList, opts v1.UpdateOptions) (*v1beta1.ServiceSubscriptionList, error)
+	UpdateStatus(ctx context.Context, serviceSubscriptionList *v1beta1.ServiceSubscriptionList, opts v1.UpdateOptions) (*v1beta1.ServiceSubscriptionList, error)
+	Delete(ctx context.Context, name string, opts v1.DeleteOptions) error
+	DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error
+	Get(ctx context.Context, name string, opts v1.GetOptions) (*v1beta1.ServiceSubscriptionList, error)
+	List(ctx context.Context, opts v1.ListOptions) (*v1beta1.ServiceSubscriptionListList, error)
+	Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error)
+	Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *v1beta1.ServiceSubscriptionList, err error)
+	ServiceSubscriptionListExpansion
+}
+
+// serviceSubscriptionLists implements ServiceSubscriptionListInterface
+type serviceSubscriptionLists struct {
+	client rest.Interface
+	ns     string
+}
+
+// newServiceSubscriptionLists returns a ServiceSubscriptionLists
+func newServiceSubscriptionLists(c *NetworkingV1beta1Client, namespace string) *serviceSubscriptionLists {
+	return &serviceSubscriptionLists{
+		client: c.RESTClient(),
+		ns:     namespace,
+	}
+}
+
+// Get takes name of the serviceSubscriptionList, and returns the corresponding serviceSubscriptionList object, and an error if there is any.
+func (c *serviceSubscriptionLists) Get(ctx context.Context, name string, options v1.GetOptions) (result *v1beta1.ServiceSubscriptionList, err error) {
+	result = &v1beta1.ServiceSubscriptionList{}
+	err = c.client.Get().
+		Namespace(c.ns).
+		Resource("servicesubscriptionlists").
+		Name(name).
+		VersionedParams(&options, scheme.ParameterCodec).
+		Do(ctx).
+		Into(result)
+	return
+}
+
+// List takes label and field selectors, and returns the list of ServiceSubscriptionLists that match those selectors.
+func (c *serviceSubscriptionLists) List(ctx context.Context, opts v1.ListOptions) (result *v1beta1.ServiceSubscriptionListList, err error) {
+	var timeout time.Duration
+	if opts.TimeoutSeconds != nil {
+		timeout = time.Duration(*opts.TimeoutSeconds) * time.Second
+	}
+	result = &v1beta1.ServiceSubscriptionListList{}
+	err = c.client.Get().
+		Namespace(c.ns).
+		Resource("servicesubscriptionlists").
+		VersionedParams(&opts, scheme.ParameterCodec).
+		Timeout(timeout).
+		Do(ctx).
+		Into(result)
+	return
+}
+
+// Watch returns a watch.Interface that watches the requested serviceSubscriptionLists.
+func (c *serviceSubscriptionLists) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
+	var timeout time.Duration
+	if opts.TimeoutSeconds != nil {
+		timeout = time.Duration(*opts.TimeoutSeconds) * time.Second
+	}
+	opts.Watch = true
+	return c.client.Get().
+		Namespace(c.ns).
+		Resource("servicesubscriptionlists").
+		VersionedParams(&opts, scheme.ParameterCodec).
+		Timeout(timeout).
+		Watch(ctx)
+}
+
+// Create takes the representation of a serviceSubscriptionList and creates it.  Returns the server's representation of the serviceSubscriptionList, and an error, if there is any.
+func (c *serviceSubscriptionLists) Create(ctx context.Context, serviceSubscriptionList *v1beta1.ServiceSubscriptionList, opts v1.CreateOptions) (result *v1beta1.ServiceSubscriptionList, err error) {
+	result = &v1beta1.ServiceSubscriptionList{}
+	err = c.client.Post().
+		Namespace(c.ns).
+		Resource("servicesubscriptionlists").
+		VersionedParams(&opts, scheme.ParameterCodec).
+		Body(serviceSubscriptionList).
+		Do(ctx).
+		Into(result)
+	return
+}
+
+// Update takes the representation of a serviceSubscriptionList and updates it. Returns the server's representation of the serviceSubscriptionList, and an error, if there is any.
+func (c *serviceSubscriptionLists) Update(ctx context.Context, serviceSubscriptionList *v1beta1.ServiceSubscriptionList, opts v1.UpdateOptions) (result *v1beta1.ServiceSubscriptionList, err error) {
+	result = &v1beta1.ServiceSubscriptionList{}
+	err = c.client.Put().
+		Namespace(c.ns).
+		Resource("servicesubscriptionlists").
+		Name(serviceSubscriptionList.Name).
+		VersionedParams(&opts, scheme.ParameterCodec).
+		Body(serviceSubscriptionList).
+		Do(ctx).
+		Into(result)
+	return
+}
+
+// UpdateStatus was generated because the type contains a Status member.
+// Add a +genclient:noStatus comment above the type to avoid generating UpdateStatus().
+func (c *serviceSubscriptionLists) UpdateStatus(ctx context.Context, serviceSubscriptionList *v1beta1.ServiceSubscriptionList, opts v1.UpdateOptions) (result *v1beta1.ServiceSubscriptionList, err error) {
+	result = &v1beta1.ServiceSubscriptionList{}
+	err = c.client.Put().
+		Namespace(c.ns).
+		Resource("servicesubscriptionlists").
+		Name(serviceSubscriptionList.Name).
+		SubResource("status").
+		VersionedParams(&opts, scheme.ParameterCodec).
+		Body(serviceSubscriptionList).
+		Do(ctx).
+		Into(result)
+	return
+}
+
+// Delete takes name of the serviceSubscriptionList and deletes it. Returns an error if one occurs.
+func (c *serviceSubscriptionLists) Delete(ctx context.Context, name string, opts v1.DeleteOptions) error {
+	return c.client.Delete().
+		Namespace(c.ns).
+		Resource("servicesubscriptionlists").
+		Name(name).
+		Body(&opts).
+		Do(ctx).
+		Error()
+}
+
+// DeleteCollection deletes a collection of objects.
+func (c *serviceSubscriptionLists) DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error {
+	var timeout time.Duration
+	if listOpts.TimeoutSeconds != nil {
+		timeout = time.Duration(*listOpts.TimeoutSeconds) * time.Second
+	}
+	return c.client.Delete().
+		Namespace(c.ns).
+		Resource("servicesubscriptionlists").
+		VersionedParams(&listOpts, scheme.ParameterCodec).
+		Timeout(timeout).
+		Body(&opts).
+		Do(ctx).
+		Error()
+}
+
+// Patch applies the patch and returns the patched serviceSubscriptionList.
+func (c *serviceSubscriptionLists) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *v1beta1.ServiceSubscriptionList, err error) {
+	result = &v1beta1.ServiceSubscriptionList{}
+	err = c.client.Patch(pt).
+		Namespace(c.ns).
+		Resource("servicesubscriptionlists").
+		Name(name).
+		SubResource(subresources...).
+		VersionedParams(&opts, scheme.ParameterCodec).
+		Body(data).
+		Do(ctx).
+		Into(result)
+	return
+}
diff --git a/pkg/informers/externalversions/generic.gen.go b/pkg/informers/externalversions/generic.gen.go
index 01b393f..11026a1 100644
--- a/pkg/informers/externalversions/generic.gen.go
+++ b/pkg/informers/externalversions/generic.gen.go
@@ -67,6 +67,8 @@ func (f *sharedInformerFactory) ForResource(resource schema.GroupVersionResource
 		return &genericInformer{resource: resource.GroupResource(), informer: f.Networking().V1alpha3().Gateways().Informer()}, nil
 	case v1alpha3.SchemeGroupVersion.WithResource("serviceentries"):
 		return &genericInformer{resource: resource.GroupResource(), informer: f.Networking().V1alpha3().ServiceEntries().Informer()}, nil
+	case v1alpha3.SchemeGroupVersion.WithResource("servicesubscriptionlists"):
+		return &genericInformer{resource: resource.GroupResource(), informer: f.Networking().V1alpha3().ServiceSubscriptionLists().Informer()}, nil
 	case v1alpha3.SchemeGroupVersion.WithResource("sidecars"):
 		return &genericInformer{resource: resource.GroupResource(), informer: f.Networking().V1alpha3().Sidecars().Informer()}, nil
 	case v1alpha3.SchemeGroupVersion.WithResource("virtualservices"):
@@ -83,6 +85,8 @@ func (f *sharedInformerFactory) ForResource(resource schema.GroupVersionResource
 		return &genericInformer{resource: resource.GroupResource(), informer: f.Networking().V1beta1().Gateways().Informer()}, nil
 	case v1beta1.SchemeGroupVersion.WithResource("serviceentries"):
 		return &genericInformer{resource: resource.GroupResource(), informer: f.Networking().V1beta1().ServiceEntries().Informer()}, nil
+	case v1beta1.SchemeGroupVersion.WithResource("servicesubscriptionlists"):
+		return &genericInformer{resource: resource.GroupResource(), informer: f.Networking().V1beta1().ServiceSubscriptionLists().Informer()}, nil
 	case v1beta1.SchemeGroupVersion.WithResource("sidecars"):
 		return &genericInformer{resource: resource.GroupResource(), informer: f.Networking().V1beta1().Sidecars().Informer()}, nil
 	case v1beta1.SchemeGroupVersion.WithResource("virtualservices"):
diff --git a/pkg/informers/externalversions/networking/v1alpha3/interface.gen.go b/pkg/informers/externalversions/networking/v1alpha3/interface.gen.go
index ce0dafa..96c0b5d 100644
--- a/pkg/informers/externalversions/networking/v1alpha3/interface.gen.go
+++ b/pkg/informers/externalversions/networking/v1alpha3/interface.gen.go
@@ -30,6 +30,8 @@ type Interface interface {
 	Gateways() GatewayInformer
 	// ServiceEntries returns a ServiceEntryInformer.
 	ServiceEntries() ServiceEntryInformer
+	// ServiceSubscriptionLists returns a ServiceSubscriptionListInformer.
+	ServiceSubscriptionLists() ServiceSubscriptionListInformer
 	// Sidecars returns a SidecarInformer.
 	Sidecars() SidecarInformer
 	// VirtualServices returns a VirtualServiceInformer.
@@ -71,6 +73,11 @@ func (v *version) ServiceEntries() ServiceEntryInformer {
 	return &serviceEntryInformer{factory: v.factory, namespace: v.namespace, tweakListOptions: v.tweakListOptions}
 }
 
+// ServiceSubscriptionLists returns a ServiceSubscriptionListInformer.
+func (v *version) ServiceSubscriptionLists() ServiceSubscriptionListInformer {
+	return &serviceSubscriptionListInformer{factory: v.factory, namespace: v.namespace, tweakListOptions: v.tweakListOptions}
+}
+
 // Sidecars returns a SidecarInformer.
 func (v *version) Sidecars() SidecarInformer {
 	return &sidecarInformer{factory: v.factory, namespace: v.namespace, tweakListOptions: v.tweakListOptions}
diff --git a/pkg/informers/externalversions/networking/v1alpha3/servicesubscriptionlist.gen.go b/pkg/informers/externalversions/networking/v1alpha3/servicesubscriptionlist.gen.go
new file mode 100644
index 0000000..d9b7e46
--- /dev/null
+++ b/pkg/informers/externalversions/networking/v1alpha3/servicesubscriptionlist.gen.go
@@ -0,0 +1,88 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// Code generated by informer-gen. DO NOT EDIT.
+
+package v1alpha3
+
+import (
+	"context"
+	time "time"
+
+	networkingv1alpha3 "istio.io/client-go/pkg/apis/networking/v1alpha3"
+	versioned "istio.io/client-go/pkg/clientset/versioned"
+	internalinterfaces "istio.io/client-go/pkg/informers/externalversions/internalinterfaces"
+	v1alpha3 "istio.io/client-go/pkg/listers/networking/v1alpha3"
+	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	runtime "k8s.io/apimachinery/pkg/runtime"
+	watch "k8s.io/apimachinery/pkg/watch"
+	cache "k8s.io/client-go/tools/cache"
+)
+
+// ServiceSubscriptionListInformer provides access to a shared informer and lister for
+// ServiceSubscriptionLists.
+type ServiceSubscriptionListInformer interface {
+	Informer() cache.SharedIndexInformer
+	Lister() v1alpha3.ServiceSubscriptionListLister
+}
+
+type serviceSubscriptionListInformer struct {
+	factory          internalinterfaces.SharedInformerFactory
+	tweakListOptions internalinterfaces.TweakListOptionsFunc
+	namespace        string
+}
+
+// NewServiceSubscriptionListInformer constructs a new informer for ServiceSubscriptionList type.
+// Always prefer using an informer factory to get a shared informer instead of getting an independent
+// one. This reduces memory footprint and number of connections to the server.
+func NewServiceSubscriptionListInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers) cache.SharedIndexInformer {
+	return NewFilteredServiceSubscriptionListInformer(client, namespace, resyncPeriod, indexers, nil)
+}
+
+// NewFilteredServiceSubscriptionListInformer constructs a new informer for ServiceSubscriptionList type.
+// Always prefer using an informer factory to get a shared informer instead of getting an independent
+// one. This reduces memory footprint and number of connections to the server.
+func NewFilteredServiceSubscriptionListInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers, tweakListOptions internalinterfaces.TweakListOptionsFunc) cache.SharedIndexInformer {
+	return cache.NewSharedIndexInformer(
+		&cache.ListWatch{
+			ListFunc: func(options v1.ListOptions) (runtime.Object, error) {
+				if tweakListOptions != nil {
+					tweakListOptions(&options)
+				}
+				return client.NetworkingV1alpha3().ServiceSubscriptionLists(namespace).List(context.TODO(), options)
+			},
+			WatchFunc: func(options v1.ListOptions) (watch.Interface, error) {
+				if tweakListOptions != nil {
+					tweakListOptions(&options)
+				}
+				return client.NetworkingV1alpha3().ServiceSubscriptionLists(namespace).Watch(context.TODO(), options)
+			},
+		},
+		&networkingv1alpha3.ServiceSubscriptionList{},
+		resyncPeriod,
+		indexers,
+	)
+}
+
+func (f *serviceSubscriptionListInformer) defaultInformer(client versioned.Interface, resyncPeriod time.Duration) cache.SharedIndexInformer {
+	return NewFilteredServiceSubscriptionListInformer(client, f.namespace, resyncPeriod, cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc}, f.tweakListOptions)
+}
+
+func (f *serviceSubscriptionListInformer) Informer() cache.SharedIndexInformer {
+	return f.factory.InformerFor(&networkingv1alpha3.ServiceSubscriptionList{}, f.defaultInformer)
+}
+
+func (f *serviceSubscriptionListInformer) Lister() v1alpha3.ServiceSubscriptionListLister {
+	return v1alpha3.NewServiceSubscriptionListLister(f.Informer().GetIndexer())
+}
diff --git a/pkg/informers/externalversions/networking/v1beta1/interface.gen.go b/pkg/informers/externalversions/networking/v1beta1/interface.gen.go
index ea1c0ac..2ce333f 100644
--- a/pkg/informers/externalversions/networking/v1beta1/interface.gen.go
+++ b/pkg/informers/externalversions/networking/v1beta1/interface.gen.go
@@ -28,6 +28,8 @@ type Interface interface {
 	Gateways() GatewayInformer
 	// ServiceEntries returns a ServiceEntryInformer.
 	ServiceEntries() ServiceEntryInformer
+	// ServiceSubscriptionLists returns a ServiceSubscriptionListInformer.
+	ServiceSubscriptionLists() ServiceSubscriptionListInformer
 	// Sidecars returns a SidecarInformer.
 	Sidecars() SidecarInformer
 	// VirtualServices returns a VirtualServiceInformer.
@@ -62,6 +64,11 @@ func (v *version) ServiceEntries() ServiceEntryInformer {
 	return &serviceEntryInformer{factory: v.factory, namespace: v.namespace, tweakListOptions: v.tweakListOptions}
 }
 
+// ServiceSubscriptionLists returns a ServiceSubscriptionListInformer.
+func (v *version) ServiceSubscriptionLists() ServiceSubscriptionListInformer {
+	return &serviceSubscriptionListInformer{factory: v.factory, namespace: v.namespace, tweakListOptions: v.tweakListOptions}
+}
+
 // Sidecars returns a SidecarInformer.
 func (v *version) Sidecars() SidecarInformer {
 	return &sidecarInformer{factory: v.factory, namespace: v.namespace, tweakListOptions: v.tweakListOptions}
diff --git a/pkg/informers/externalversions/networking/v1beta1/servicesubscriptionlist.gen.go b/pkg/informers/externalversions/networking/v1beta1/servicesubscriptionlist.gen.go
new file mode 100644
index 0000000..2da4729
--- /dev/null
+++ b/pkg/informers/externalversions/networking/v1beta1/servicesubscriptionlist.gen.go
@@ -0,0 +1,88 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// Code generated by informer-gen. DO NOT EDIT.
+
+package v1beta1
+
+import (
+	"context"
+	time "time"
+
+	networkingv1beta1 "istio.io/client-go/pkg/apis/networking/v1beta1"
+	versioned "istio.io/client-go/pkg/clientset/versioned"
+	internalinterfaces "istio.io/client-go/pkg/informers/externalversions/internalinterfaces"
+	v1beta1 "istio.io/client-go/pkg/listers/networking/v1beta1"
+	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	runtime "k8s.io/apimachinery/pkg/runtime"
+	watch "k8s.io/apimachinery/pkg/watch"
+	cache "k8s.io/client-go/tools/cache"
+)
+
+// ServiceSubscriptionListInformer provides access to a shared informer and lister for
+// ServiceSubscriptionLists.
+type ServiceSubscriptionListInformer interface {
+	Informer() cache.SharedIndexInformer
+	Lister() v1beta1.ServiceSubscriptionListLister
+}
+
+type serviceSubscriptionListInformer struct {
+	factory          internalinterfaces.SharedInformerFactory
+	tweakListOptions internalinterfaces.TweakListOptionsFunc
+	namespace        string
+}
+
+// NewServiceSubscriptionListInformer constructs a new informer for ServiceSubscriptionList type.
+// Always prefer using an informer factory to get a shared informer instead of getting an independent
+// one. This reduces memory footprint and number of connections to the server.
+func NewServiceSubscriptionListInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers) cache.SharedIndexInformer {
+	return NewFilteredServiceSubscriptionListInformer(client, namespace, resyncPeriod, indexers, nil)
+}
+
+// NewFilteredServiceSubscriptionListInformer constructs a new informer for ServiceSubscriptionList type.
+// Always prefer using an informer factory to get a shared informer instead of getting an independent
+// one. This reduces memory footprint and number of connections to the server.
+func NewFilteredServiceSubscriptionListInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers, tweakListOptions internalinterfaces.TweakListOptionsFunc) cache.SharedIndexInformer {
+	return cache.NewSharedIndexInformer(
+		&cache.ListWatch{
+			ListFunc: func(options v1.ListOptions) (runtime.Object, error) {
+				if tweakListOptions != nil {
+					tweakListOptions(&options)
+				}
+				return client.NetworkingV1beta1().ServiceSubscriptionLists(namespace).List(context.TODO(), options)
+			},
+			WatchFunc: func(options v1.ListOptions) (watch.Interface, error) {
+				if tweakListOptions != nil {
+					tweakListOptions(&options)
+				}
+				return client.NetworkingV1beta1().ServiceSubscriptionLists(namespace).Watch(context.TODO(), options)
+			},
+		},
+		&networkingv1beta1.ServiceSubscriptionList{},
+		resyncPeriod,
+		indexers,
+	)
+}
+
+func (f *serviceSubscriptionListInformer) defaultInformer(client versioned.Interface, resyncPeriod time.Duration) cache.SharedIndexInformer {
+	return NewFilteredServiceSubscriptionListInformer(client, f.namespace, resyncPeriod, cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc}, f.tweakListOptions)
+}
+
+func (f *serviceSubscriptionListInformer) Informer() cache.SharedIndexInformer {
+	return f.factory.InformerFor(&networkingv1beta1.ServiceSubscriptionList{}, f.defaultInformer)
+}
+
+func (f *serviceSubscriptionListInformer) Lister() v1beta1.ServiceSubscriptionListLister {
+	return v1beta1.NewServiceSubscriptionListLister(f.Informer().GetIndexer())
+}
diff --git a/pkg/listers/networking/v1alpha3/expansion_generated.gen.go b/pkg/listers/networking/v1alpha3/expansion_generated.gen.go
index 5714ddc..8133eee 100644
--- a/pkg/listers/networking/v1alpha3/expansion_generated.gen.go
+++ b/pkg/listers/networking/v1alpha3/expansion_generated.gen.go
@@ -48,6 +48,14 @@ type ServiceEntryListerExpansion interface{}
 // ServiceEntryNamespaceLister.
 type ServiceEntryNamespaceListerExpansion interface{}
 
+// ServiceSubscriptionListListerExpansion allows custom methods to be added to
+// ServiceSubscriptionListLister.
+type ServiceSubscriptionListListerExpansion interface{}
+
+// ServiceSubscriptionListNamespaceListerExpansion allows custom methods to be added to
+// ServiceSubscriptionListNamespaceLister.
+type ServiceSubscriptionListNamespaceListerExpansion interface{}
+
 // SidecarListerExpansion allows custom methods to be added to
 // SidecarLister.
 type SidecarListerExpansion interface{}
diff --git a/pkg/listers/networking/v1alpha3/servicesubscriptionlist.gen.go b/pkg/listers/networking/v1alpha3/servicesubscriptionlist.gen.go
new file mode 100644
index 0000000..d63da76
--- /dev/null
+++ b/pkg/listers/networking/v1alpha3/servicesubscriptionlist.gen.go
@@ -0,0 +1,92 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// Code generated by lister-gen. DO NOT EDIT.
+
+package v1alpha3
+
+import (
+	v1alpha3 "istio.io/client-go/pkg/apis/networking/v1alpha3"
+	"k8s.io/apimachinery/pkg/api/errors"
+	"k8s.io/apimachinery/pkg/labels"
+	"k8s.io/client-go/tools/cache"
+)
+
+// ServiceSubscriptionListLister helps list ServiceSubscriptionLists.
+type ServiceSubscriptionListLister interface {
+	// List lists all ServiceSubscriptionLists in the indexer.
+	List(selector labels.Selector) (ret []*v1alpha3.ServiceSubscriptionList, err error)
+	// ServiceSubscriptionLists returns an object that can list and get ServiceSubscriptionLists.
+	ServiceSubscriptionLists(namespace string) ServiceSubscriptionListNamespaceLister
+	ServiceSubscriptionListListerExpansion
+}
+
+// serviceSubscriptionListLister implements the ServiceSubscriptionListLister interface.
+type serviceSubscriptionListLister struct {
+	indexer cache.Indexer
+}
+
+// NewServiceSubscriptionListLister returns a new ServiceSubscriptionListLister.
+func NewServiceSubscriptionListLister(indexer cache.Indexer) ServiceSubscriptionListLister {
+	return &serviceSubscriptionListLister{indexer: indexer}
+}
+
+// List lists all ServiceSubscriptionLists in the indexer.
+func (s *serviceSubscriptionListLister) List(selector labels.Selector) (ret []*v1alpha3.ServiceSubscriptionList, err error) {
+	err = cache.ListAll(s.indexer, selector, func(m interface{}) {
+		ret = append(ret, m.(*v1alpha3.ServiceSubscriptionList))
+	})
+	return ret, err
+}
+
+// ServiceSubscriptionLists returns an object that can list and get ServiceSubscriptionLists.
+func (s *serviceSubscriptionListLister) ServiceSubscriptionLists(namespace string) ServiceSubscriptionListNamespaceLister {
+	return serviceSubscriptionListNamespaceLister{indexer: s.indexer, namespace: namespace}
+}
+
+// ServiceSubscriptionListNamespaceLister helps list and get ServiceSubscriptionLists.
+type ServiceSubscriptionListNamespaceLister interface {
+	// List lists all ServiceSubscriptionLists in the indexer for a given namespace.
+	List(selector labels.Selector) (ret []*v1alpha3.ServiceSubscriptionList, err error)
+	// Get retrieves the ServiceSubscriptionList from the indexer for a given namespace and name.
+	Get(name string) (*v1alpha3.ServiceSubscriptionList, error)
+	ServiceSubscriptionListNamespaceListerExpansion
+}
+
+// serviceSubscriptionListNamespaceLister implements the ServiceSubscriptionListNamespaceLister
+// interface.
+type serviceSubscriptionListNamespaceLister struct {
+	indexer   cache.Indexer
+	namespace string
+}
+
+// List lists all ServiceSubscriptionLists in the indexer for a given namespace.
+func (s serviceSubscriptionListNamespaceLister) List(selector labels.Selector) (ret []*v1alpha3.ServiceSubscriptionList, err error) {
+	err = cache.ListAllByNamespace(s.indexer, s.namespace, selector, func(m interface{}) {
+		ret = append(ret, m.(*v1alpha3.ServiceSubscriptionList))
+	})
+	return ret, err
+}
+
+// Get retrieves the ServiceSubscriptionList from the indexer for a given namespace and name.
+func (s serviceSubscriptionListNamespaceLister) Get(name string) (*v1alpha3.ServiceSubscriptionList, error) {
+	obj, exists, err := s.indexer.GetByKey(s.namespace + "/" + name)
+	if err != nil {
+		return nil, err
+	}
+	if !exists {
+		return nil, errors.NewNotFound(v1alpha3.Resource("servicesubscriptionlist"), name)
+	}
+	return obj.(*v1alpha3.ServiceSubscriptionList), nil
+}
diff --git a/pkg/listers/networking/v1beta1/expansion_generated.gen.go b/pkg/listers/networking/v1beta1/expansion_generated.gen.go
index c223761..b87ea41 100644
--- a/pkg/listers/networking/v1beta1/expansion_generated.gen.go
+++ b/pkg/listers/networking/v1beta1/expansion_generated.gen.go
@@ -40,6 +40,14 @@ type ServiceEntryListerExpansion interface{}
 // ServiceEntryNamespaceLister.
 type ServiceEntryNamespaceListerExpansion interface{}
 
+// ServiceSubscriptionListListerExpansion allows custom methods to be added to
+// ServiceSubscriptionListLister.
+type ServiceSubscriptionListListerExpansion interface{}
+
+// ServiceSubscriptionListNamespaceListerExpansion allows custom methods to be added to
+// ServiceSubscriptionListNamespaceLister.
+type ServiceSubscriptionListNamespaceListerExpansion interface{}
+
 // SidecarListerExpansion allows custom methods to be added to
 // SidecarLister.
 type SidecarListerExpansion interface{}
diff --git a/pkg/listers/networking/v1beta1/servicesubscriptionlist.gen.go b/pkg/listers/networking/v1beta1/servicesubscriptionlist.gen.go
new file mode 100644
index 0000000..b405a49
--- /dev/null
+++ b/pkg/listers/networking/v1beta1/servicesubscriptionlist.gen.go
@@ -0,0 +1,92 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// Code generated by lister-gen. DO NOT EDIT.
+
+package v1beta1
+
+import (
+	v1beta1 "istio.io/client-go/pkg/apis/networking/v1beta1"
+	"k8s.io/apimachinery/pkg/api/errors"
+	"k8s.io/apimachinery/pkg/labels"
+	"k8s.io/client-go/tools/cache"
+)
+
+// ServiceSubscriptionListLister helps list ServiceSubscriptionLists.
+type ServiceSubscriptionListLister interface {
+	// List lists all ServiceSubscriptionLists in the indexer.
+	List(selector labels.Selector) (ret []*v1beta1.ServiceSubscriptionList, err error)
+	// ServiceSubscriptionLists returns an object that can list and get ServiceSubscriptionLists.
+	ServiceSubscriptionLists(namespace string) ServiceSubscriptionListNamespaceLister
+	ServiceSubscriptionListListerExpansion
+}
+
+// serviceSubscriptionListLister implements the ServiceSubscriptionListLister interface.
+type serviceSubscriptionListLister struct {
+	indexer cache.Indexer
+}
+
+// NewServiceSubscriptionListLister returns a new ServiceSubscriptionListLister.
+func NewServiceSubscriptionListLister(indexer cache.Indexer) ServiceSubscriptionListLister {
+	return &serviceSubscriptionListLister{indexer: indexer}
+}
+
+// List lists all ServiceSubscriptionLists in the indexer.
+func (s *serviceSubscriptionListLister) List(selector labels.Selector) (ret []*v1beta1.ServiceSubscriptionList, err error) {
+	err = cache.ListAll(s.indexer, selector, func(m interface{}) {
+		ret = append(ret, m.(*v1beta1.ServiceSubscriptionList))
+	})
+	return ret, err
+}
+
+// ServiceSubscriptionLists returns an object that can list and get ServiceSubscriptionLists.
+func (s *serviceSubscriptionListLister) ServiceSubscriptionLists(namespace string) ServiceSubscriptionListNamespaceLister {
+	return serviceSubscriptionListNamespaceLister{indexer: s.indexer, namespace: namespace}
+}
+
+// ServiceSubscriptionListNamespaceLister helps list and get ServiceSubscriptionLists.
+type ServiceSubscriptionListNamespaceLister interface {
+	// List lists all ServiceSubscriptionLists in the indexer for a given namespace.
+	List(selector labels.Selector) (ret []*v1beta1.ServiceSubscriptionList, err error)
+	// Get retrieves the ServiceSubscriptionList from the indexer for a given namespace and name.
+	Get(name string) (*v1beta1.ServiceSubscriptionList, error)
+	ServiceSubscriptionListNamespaceListerExpansion
+}
+
+// serviceSubscriptionListNamespaceLister implements the ServiceSubscriptionListNamespaceLister
+// interface.
+type serviceSubscriptionListNamespaceLister struct {
+	indexer   cache.Indexer
+	namespace string
+}
+
+// List lists all ServiceSubscriptionLists in the indexer for a given namespace.
+func (s serviceSubscriptionListNamespaceLister) List(selector labels.Selector) (ret []*v1beta1.ServiceSubscriptionList, err error) {
+	err = cache.ListAllByNamespace(s.indexer, s.namespace, selector, func(m interface{}) {
+		ret = append(ret, m.(*v1beta1.ServiceSubscriptionList))
+	})
+	return ret, err
+}
+
+// Get retrieves the ServiceSubscriptionList from the indexer for a given namespace and name.
+func (s serviceSubscriptionListNamespaceLister) Get(name string) (*v1beta1.ServiceSubscriptionList, error) {
+	obj, exists, err := s.indexer.GetByKey(s.namespace + "/" + name)
+	if err != nil {
+		return nil, err
+	}
+	if !exists {
+		return nil, errors.NewNotFound(v1beta1.Resource("servicesubscriptionlist"), name)
+	}
+	return obj.(*v1beta1.ServiceSubscriptionList), nil
+}
